---
title: 学习路线
createTime: 2025/12/27 12:26:21
permalink: /blog/q7vudd7b/
---
结合你**基础优先+按需学习**的自由人路线，排序算法和后端网络这两块内容，核心是**学“实用的核心知识点”+“落地场景”**，不用死磕冷门内容。以下是针对性的学习重点：

## 一、 排序算法：学“常用的+能说清原理+知道适用场景”
排序算法是数据结构的核心，后端开发中经常用到（比如数据库索引、接口返回数据排序），不用学所有排序，重点抓 **3类核心排序** + **2个关键思想**。

### 1.  必须掌握的3种排序（工作中高频用到）
| 排序算法 | 核心原理 | 适用场景 | 学习重点 |
|----------|----------|----------|----------|
| **快速排序** | 分治思想：选一个“基准值”，把数组分成“小于基准”和“大于基准”两部分，递归排序子数组 | 绝大多数业务场景（速度快、效率高），比如接口返回列表排序、数据库内部排序 | 1. 理解“分治”的核心逻辑；<br>2. 知道它的**时间复杂度**（平均O(nlogn)，最坏O(n²)）；<br>3. 能手写“简单版快排”（不用纠结工业级优化） |
| **归并排序** | 分治思想：先把数组拆成最小单元，再两两合并成有序数组 | 外部排序（数据量超大，内存装不下）、需要**稳定排序**的场景 | 1. 理解“拆分+合并”的步骤；<br>2. 记住它是**稳定排序**（相同值的元素排序后相对位置不变）；<br>3. 时间复杂度稳定O(nlogn) |
| **冒泡/插入排序** | 冒泡：相邻元素两两比较，大的往后“冒”；<br>插入：把元素逐个插入到已排序的序列中 | 数据量**极小**的场景（比如n<100），或者作为理解排序的入门案例 | 1. 能快速写出代码（逻辑简单）；<br>2. 知道时间复杂度O(n²)，**不适合大数据量** |

### 2.  2个关键思想（比死记算法更重要）
- **分治思想**：快排和归并的核心，本质是“大问题拆成小问题，解决小问题后合并结果”—— 这种思想在后端开发中随处可见（比如分布式系统拆分任务）。
- **稳定排序 vs 不稳定排序**：
  - 稳定：归并、冒泡、插入（适合对“有重复值的对象”排序，比如按价格排序商品，相同价格的商品保持原顺序）。
  - 不稳定：快排、选择排序（不关心元素相对位置时用）。

### 3.  后端开发中的“排序实战”
- **业务代码中**：不用自己手写排序！大部分语言都有内置排序函数（比如Python的`sorted()`、Java的`Arrays.sort()`），这些函数底层是优化过的快排/归并，你只需要：
  1.  会用内置函数（比如给列表、对象列表排序）。
  2.  知道什么时候该用哪种排序（比如小数据用插入，大数据用快排）。
- **面试/底层理解中**：能说清快排的原理、时间复杂度、适用场景，就足够应对大部分情况。

## 二、 后端网络：学“和后端开发直接相关的协议+核心流程”
后端网络的核心是 **“数据怎么在客户端和服务器之间传输”**，不用深钻网络底层（比如TCP的三次握手四次挥手的每一个字节），重点抓 **3层核心内容**。

### 1.  必须掌握的网络协议（后端开发天天用）
| 协议 | 核心作用 | 学习重点 |
|------|----------|----------|
| **HTTP/HTTPS** | 客户端和服务器的“通信语言”（比如浏览器发请求、后端接口响应） | 1. **HTTP请求的组成**：请求行（Method/URL/版本）、请求头（Content-Type/Cookie）、请求体（POST数据）；<br>2. **常见Method**：GET（查数据，幂等）、POST（增数据，非幂等）、PUT/PATCH/DELETE的区别；<br>3. **HTTP状态码**：2xx（成功）、3xx（重定向）、4xx（客户端错，比如404/403）、5xx（服务端错，比如500）；<br>4. **HTTPS的作用**：加密传输（SSL/TLS协议），解决HTTP的明文传输安全问题 |
| **TCP/UDP** | 传输层协议，负责数据在两台机器之间的可靠传输 | 1. **TCP的核心特点**：面向连接、可靠传输（三次握手建立连接，四次挥手断开，丢包重传）—— 适合后端接口、文件传输等需要可靠的场景；<br>2. **UDP的核心特点**：无连接、不可靠（发了就不管）—— 适合直播、实时聊天等对速度要求高于可靠性的场景；<br>3. **后端开发中**：你写的接口默认用TCP，不用手动处理握手，框架会帮你搞定，但要知道“为什么接口用TCP而不是UDP” |
| **DNS** | 域名解析协议（比如把`www.xxx.com`转成服务器IP） | 1. **核心流程**：客户端→本地DNS→根DNS→顶级DNS→权威DNS→返回IP；<br>2. **后端部署中**：你搭的服务需要绑定域名，知道DNS解析的过程，能排查“域名解析失败”的问题 |

### 2.  后端网络核心流程：“一次HTTP请求的完整生命周期”
这是后端开发的**核心知识点**，必须搞懂：
1.  客户端输入URL，浏览器先查本地DNS缓存，获取服务器IP。
2.  客户端和服务器通过**TCP三次握手**建立连接。
3.  客户端发送HTTP请求（比如GET /api/user）。
4.  服务器接收请求，处理业务逻辑（查数据库、计算数据）。
5.  服务器返回HTTP响应（状态码+响应头+响应体）。
6.  客户端和服务器通过**TCP四次挥手**断开连接。
7.  浏览器渲染响应数据（如果是前端页面）。

### 3.  后端开发中的“网络实战”
- **接口开发**：
  1.  会设置请求头（比如`Content-Type: application/json`表示JSON数据）。
  2.  会根据业务返回正确的状态码（比如查询成功返回200，参数错误返回400）。
  3.  知道HTTPS的配置（比如在Nginx上配置SSL证书）。
- **问题排查**：
  1.  用`ping`命令测试服务器是否可达。
  2.  用`curl`命令模拟HTTP请求（比如`curl -X GET https://xxx.com/api/user`）。
  3.  用抓包工具（Wireshark/Fiddler）看请求和响应的详细内容，排查接口报错问题。

### 4.  进阶知识点（按需学习）
- 当你做**高并发后端**时，再学：
  - HTTP/2的特性（多路复用、头部压缩）。
  - TCP的拥塞控制（慢启动、拥塞避免）。
  - 反向代理（Nginx）的作用（负载均衡、动静分离）。

## 关键学习原则
1.  **排序算法**：**“理解原理 > 手写代码”**，业务中优先用内置函数，底层原理是为了应对复杂场景和面试。
2.  **后端网络**：**“结合业务场景学”**，比如写一个接口后，回头梳理一遍“这个接口的HTTP请求流程”，比死记协议文档更有效。
3.  **按需深入**：比如你做实时聊天工具，再深入学UDP；做分布式系统，再深入学TCP的可靠性。

是否需要我帮你整理一份 **排序算法+后端网络的自查清单**，方便你检验自己的掌握程度？